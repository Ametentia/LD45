#include "Ludum_Assets.cpp"
#include "Ludum_Sockets.cpp"
#include "Ludum_Card_Effects.cpp"

internal void InitialiseCardIndex(Card_Index *index, Asset_Manager *assets) {
    char *card_names[] = {
        // @Note: This should be generated by the build script
        #include "Generated_Texture_Names.include"
    };

    u32 count = ArrayCount(card_names);
    Assert(ArrayCount(card_names) == CardType_Count);

    for (u32 it = 0; it < CardType_Count; ++it) {
        Card *card = &index->cards[it];

        card->type = cast(Card_Type) it;
        card->image = LoadImage(assets, card_names[it]);
        card->sound = { 0 }; // @Todo: Sound names

        card->hidden_turn_count = 0;
        card->frozen_turn_count = 0;
        card->effect_flags = 0;

        // @Hack: But its an easy way to initialise all of the cards
        switch (card->type) {
            case CardType_Back: { card->Execute = 0; card->cost = 0; } break;
            case CardType_AlternateReality: { card->Execute = AlternateReality; card->cost = 3; } break;
            case CardType_Altruism: { card->Execute = Altruism; card->cost = 6; } break;
            case CardType_BallAndChain: { card->Execute = 0; card->cost = 6; } break;
            case CardType_Barrier: { card->Execute = Barrier; card->cost = 6; } break;
            case CardType_BestIntentions: { card->Execute = BestIntentions; card->cost = 3; } break;
            case CardType_BlackHole: { card->Execute = BlackHole; card->cost = 8; } break;
            case CardType_BloodPact: { card->Execute = BloodPact; card->cost = 2; } break;
            case CardType_BoundByTime: { card->Execute = BoundByTime; card->cost = 4; } break;
            case CardType_Charity: { card->Execute = Charity; card->cost = 3; } break;
            case CardType_CompleteMeltdown: { card->Execute = CompleteMeltdown; card->cost = 4; } break;
            case CardType_DarkRitual: { card->Execute = DarkRitual; card->cost = 5; } break;
            case CardType_DarknessOfSpace: { card->Execute = DarknessOfSpace; card->cost = 2; } break;
            case CardType_DazzlingLight: { card->Execute = DazzlingLight; card->cost = 4; } break;
            case CardType_DevilsWheel: { card->Execute = DevilsWheel; card->cost = 3; } break;
            case CardType_Emc2: { card->Execute = Emc2; card->cost = 2; } break;
            case CardType_EmptyManaCrystal: { card->Execute = 0; card->cost = 1; } break;
            case CardType_EnergyInefficient: { card->Execute = EnergyInefficient; card->cost = 4; } break;
            case CardType_EventHorizon: { card->Execute = EventHorizon; card->cost = 6; } break;
            case CardType_FootingTheBill: { card->Execute = FootingTheBill; card->cost = 1; } break;
            case CardType_ForcedSalvation: { card->Execute = ForcedSalvation; card->cost = 2; } break;
            case CardType_GravitationalPull: { card->Execute = GravitationalPull; card->cost = 3; } break;
            case CardType_LuckyFeeling: { card->Execute = LuckyFeeling; card->cost = 2; } break;
            case CardType_Malfunction: { card->Execute = Malfunction; card->cost = 3; } break;
            case CardType_ManaErosion: { card->Execute = ManaErosion; card->cost = 3; } break;
            case CardType_ManaStarved: { card->Execute = ManaStarved; card->cost = 7; } break;
            case CardType_MiracleMachine: { card->Execute = MiracleMachine; card->cost = 0; } break;
            case CardType_NostalgiaTrip: { card->Execute = NostalgiaTrip; card->cost = 2; } break;
            case CardType_NotPlayingAlong: { card->Execute = NotPlayingAlong; card->cost = 4; } break;
            case CardType_Overdrive: { card->Execute = Overdrive; card->cost = 4; } break;
            case CardType_OverflowingEnergy: { card->Execute = OverflowingEnergy; card->cost = 13; } break;
            case CardType_OwnInterests: { card->Execute = OwnInterests; card->cost = 8; } break;
            case CardType_Pebbles: { card->Execute = 0; card->cost = 1; } break;
            case CardType_PlayingDumb: { card->Execute = PlayingDumb; card->cost = 2; } break;
            case CardType_PowerSurge: { card->Execute = PowerSurge; card->cost = 3; } break;
            case CardType_Premonition: { card->Execute = Premonition; card->cost = 2; } break;
            case CardType_PureAnarchy: { card->Execute = PureAnarchy; card->cost = 4; } break;
            case CardType_Recursion: { card->Execute = Recursion; card->cost = 1; } break;
            case CardType_Rewind: { card->Execute = Rewind; card->cost = 7; } break;
            case CardType_Sacrifice: { card->Execute = Sacrifice; card->cost = 0; } break;
            case CardType_SapLife: { card->Execute = SapLife; card->cost = 0; } break;
            case CardType_SpaceDebris: { card->Execute = SpaceDebris; card->cost = 2; } break;
            case CardType_TimeBomb: { card->Execute = TimeBomb; card->cost = 5; } break;
            case CardType_TimeHealsAllWounds: { card->Execute = TimeHealsAllWounds; card->cost = 5; } break;
            case CardType_UnendingTorment: { card->Execute = UnendingTorment; card->cost = 3; } break;
            case CardType_WormHole: { card->Execute = WormHole; card->cost = 5; } break;

            // Shouldn't activate
            case CardType_Count: { Assert(false); } break;
        }
    }

    printf("There are %d cards\n", CardType_Count);
}

internal void GetDeck(Board_State *board, Card *place, u32 deck_index) {
    const Card_Type *deck_type = 0;
    u32 count = 0;
    switch (deck_index) {
        case 0: { deck_type = energy_deck; count = ArrayCount(energy_deck); } break;
        case 1: { deck_type = time_and_space_deck; count = ArrayCount(time_and_space_deck); } break;
        case 2: { deck_type = chaos_deck; count = ArrayCount(chaos_deck); } break;
        default: { Assert(false); } break;
    }

    for (u32 it = 0; it < count; ++it) {
        place[it] = GetCard(board->card_index, deck_type[it]);
    }

    ShuffleCards(place, count);
}

internal void UseCard(Board_State *state, Player *player, Player *enemy, u32 index) {
    Card card = player->cards[index];

    if (player->mana >= card.cost && !(card.effect_flags & CardStatus_Frozen)) {
        printf("[Info] Player utilised card with cost %d\n", card.cost);

        player->mana -= card.cost; // @Note: Always happens
        RemoveCard(player, index);
        if (card.Execute) { card.Execute(state, player, enemy); }

        if (player->set_attack_mod) { player->set_attack_mod = false; }
        else { player->attack_modifier = 1; }

        if (HasActiveCard(player, CardType_FootingTheBill)) { enemy->temp_mana_change--; }

        player->turn_used_count++;

        player->has_card = true;
        player->used_card_display_time = 2;
        player->used_card_display_y_offset = -10;
        player->used_card_image = card.image;
    }
}

// @Note: Returns the index of the card that is being hovered over by the mouse. Only valid for the players
// cards. -1 if no cards are being hovered over
inline s32 GetCardTransforms(Game_Input *input, v2 base_position, f32 base_angle,
        v2 size, Card_Transform *transforms, u32 count)
{
    s32 result = -1;
    if (count == 0) { return result; }

    const f32 radius = 250; // How large the inner circle of the fan is
    f32 min_angle = base_angle + Max(-10.0f * (count - 1), -50);
    f32 max_angle = base_angle + Min( 10.0f * (count - 1),  50);

    if (max_angle < min_angle) { Swap(min_angle, max_angle); }

    f32 angle_offset = (max_angle - min_angle) / (count - 1);
    f32 starting_angle = min_angle;
    if (count == 1) { angle_offset = 0; }

    for (s32 it = 0; it < count; ++it) {
        Card_Transform *tx = &transforms[it];

        tx->angle = Radians(starting_angle + (it * angle_offset));
        tx->axes = V2(Sin(tx->angle), -Cos(tx->angle));
        tx->offset = radius * tx->axes;

        f32 neg_sin = Sin(-tx->angle);
        f32 neg_cos = Cos(-tx->angle);

        v2 centre = base_position + tx->offset + ((0.5f * size.y) * tx->axes);
        v2 mouse = input->mouse_position - centre;
        v2 rotated_mouse = V2(neg_cos * mouse.x - neg_sin * mouse.y, neg_sin * mouse.x + neg_cos * mouse.y);

        if (Abs(rotated_mouse.x) < (0.5f * size.x) && Abs(rotated_mouse.y) < (0.5f * size.y)) { result = it; }
    }

    return result;
}

//// @Note: Turn Phases are here

// @Phase: Draw Phase
internal void ExecuteDrawPhase(Game_State *state, Board_State *board, Game_Input *input) {
    u32 current_player = board->current_player_turn;

    Player *player = &state->players[current_player];

    if (player->max_mana < 10) { player->max_mana++; }
    player->mana = player->max_mana + player->temp_mana_change;
    if (player->mana < 0) { player->mana = 0; }

    // Draw a card if the player has less than 5 in their hand
    if (player->card_count < 5) {
        Card card = player->deck[player->next_card_index++];
        card.effect_flags = player->new_card_flags;

        if (card.effect_flags & CardStatus_Frozen) { card.frozen_turn_count = 1; }
        if (card.effect_flags & CardStatus_Hidden) { card.hidden_turn_count = 1; }

        player->cards[player->card_count++] = card;
    }

    // @Note: Clear all active cards.
    // CardType_Recursion is the only persistent active card so it is dealt with in the end phase
    s32 recursion_index = -1;
    for (u32 it = 0; it < player->active_card_count; ++it) {
        if (player->active_cards[it] == CardType_Recursion) { recursion_index = it; }
        if (player->active_cards[it] == CardType_Overdrive) {
            player->mana = (player->mana + 1) / 2; // Generous divide
        }

        // Don't really care what this is as it will be overwritten anyway
        player->active_cards[it] = cast(Card_Type) 0;
    }

    if (player->type == PlayerType_Computer) { player->card_use_time = 0; }

    player->active_card_count = 0;

    if (recursion_index != -1) { player->active_cards[0] = CardType_Recursion; player->active_card_count++; }

    if (HasActiveCard(player, CardType_Recursion)) {
        player->mana += 2;
    }

    // @Note: This will proabably go on for longer for animations and showing you the card you drew etc.
    board->phase = TurnPhase_Play;
}

// @Phase: Play Phase
internal void ExecutePlayPhase(Game_State *state, Board_State *board, Game_Input *input) {
    Game_Controller *keyboard = &input->keyboard;

    Player *player = &state->players[0];
    Player *enemy  = &state->players[1];

    Player *turn  = &state->players[board->current_player_turn];
    Player *other = &state->players[1 - board->current_player_turn];

    char buf[256];

    sfFont *font = GetFont(&state->assets, state->system_font);

    sfText *health_text = sfText_create();
    sfText_setCharacterSize(health_text, 50);
    sfText_setFont(health_text, font);
    sfText_setString(health_text, buf);

    snprintf(buf, sizeof(buf), "Player Health: %d\n", player->health);
    sfText_setString(health_text, buf);
    sfText_setPosition(health_text, V2(0, global_view_size.y - 60));
    sfRenderWindow_drawText(global_window, health_text, 0);

    snprintf(buf, sizeof(buf), "Enemy Health: %d\n", enemy->health);

    sfFloatRect text_size = sfText_getLocalBounds(health_text);
    sfText_setString(health_text, buf);
    sfText_setPosition(health_text, V2(global_view_size.x - text_size.width - 20, 0));
    sfRenderWindow_drawText(global_window, health_text, 0);

    sfText_destroy(health_text);

    if (player->health < 0 || enemy->health < 0) { state->in_menu = true; }

    // @Todo: Turns

    // Player mana crystals
    sfTexture *mana_tex = GetImage(&state->assets, state->mana_image);
    sfVector2u _mana_tex_size = sfTexture_getSize(mana_tex);
    v2 mana_tex_size = 0.15 * V2(_mana_tex_size.x, _mana_tex_size.y);
    v2 mana_begin = V2(global_view_size.x - mana_tex_size.x, global_view_size.y - mana_tex_size.y);

    v2 mana_offset = V2(mana_tex_size.x - 40, 0);

    sfRectangleShape *mana_shape = sfRectangleShape_create();
    sfRectangleShape_setTexture(mana_shape, mana_tex, true);
    sfRectangleShape_setSize(mana_shape, mana_tex_size);
    v2 cur_pos = mana_begin;
    for (u32 it = 0; it < player->max_mana; ++it) {
        if (it >= player->mana) { sfRectangleShape_setFillColor(mana_shape, sfBlack); }
        else { sfRectangleShape_setFillColor(mana_shape, sfWhite); }

        sfRectangleShape_setPosition(mana_shape, cur_pos);
        sfRenderWindow_drawRectangleShape(global_window, mana_shape, 0);

        cur_pos -= mana_offset;
    }

    // Enemy Mana cystals
    mana_begin = V2(5, 5);

    mana_offset = V2(mana_tex_size.x - 40, 0);
    sfRectangleShape_setTexture(mana_shape, mana_tex, true);
    sfRectangleShape_setSize(mana_shape, mana_tex_size);

    cur_pos = mana_begin;
    for (u32 it = 0; it < enemy->max_mana; ++it) {
        if (it > enemy->mana) { sfRectangleShape_setFillColor(mana_shape, sfBlack); }
        else { sfRectangleShape_setFillColor(mana_shape, sfWhite); }
        sfRectangleShape_setPosition(mana_shape, cur_pos);
        sfRenderWindow_drawRectangleShape(global_window, mana_shape, 0);

        cur_pos += mana_offset;
    }

    sfRectangleShape_destroy(mana_shape);

    // Size of a standard card
    sfVector2u image_size = sfTexture_getSize(GetImage(&state->assets, state->card_index.cards[0].image));
    v2 size = V2(0.5f * image_size.x, 0.5f * image_size.y);

    // Positions of the hands on screen
    f32 hand_y_offset = 200;
    v2 player_hand_position = V2(0.5f * global_view_size.x, global_view_size.y + hand_y_offset);
    v2 enemy_hand_position  = V2(0.5f * global_view_size.x, -hand_y_offset);

    // @Debug: Change card counts with keyboard
    if (JustPressed(keyboard->card_slot_3)) {
        u32 cc = player->card_count;
        cc = (cc + 1) % 11;
        player->card_count = cc;
    }

    if (JustPressed(keyboard->card_slot_5)) {
        u32 cc = enemy->card_count;
        cc = (cc + 1) % 11;
        enemy->card_count = cc;
    }

    // Get card transforms for player cards
    Card_Transform transforms[player->card_count];
    s32 hover_index = GetCardTransforms(input, player_hand_position, 0, size, transforms, player->card_count);

    // Get card transforms for enemy cards
    Card_Transform enemy_card_transforms[enemy->card_count];
    GetCardTransforms(input, enemy_hand_position, 360, size, enemy_card_transforms, enemy->card_count);

    sfRectangleShape *shadow = sfRectangleShape_create();
    sfRectangleShape *card_shape = sfRectangleShape_create();
    sfRectangleShape_setSize(card_shape, size);
    sfRectangleShape_setSize(shadow, size);
    sfRectangleShape_setTexture(shadow, GetImage(&state->assets, state->shadow_image), true);

    // Render enemy cards
    sfRectangleShape_setOrigin(shadow, V2(0.5f * size.x, 0));
    sfRectangleShape_setOrigin(card_shape, V2(0.5f * size.x, 0));
    sfRectangleShape_setTexture(card_shape, GetImage(&state->assets, GetCard(board->card_index, CardType_Back).image), true);
    for (s32 it = enemy->card_count - 1; it >= 0; --it) {
        Card *card = &enemy->cards[it];
        Card_Transform *tx = &enemy_card_transforms[it];

        v2 card_position = enemy_hand_position - tx->offset;
        v2 shadow_offset = (8 * tx->axes) + (8 * Perp(tx->axes));

        // Draw drop shadow
        sfRectangleShape_setRotation(shadow, Degrees(tx->angle));
        sfRectangleShape_setPosition(shadow, card_position - shadow_offset);
        sfRenderWindow_drawRectangleShape(global_window, shadow, 0);

        // Draw card back
        sfRectangleShape_setOrigin(card_shape, 0.5f * size);
        sfRectangleShape_setRotation(card_shape, 180);
        sfRectangleShape_setFillColor(card_shape, (card->effect_flags & CardStatus_Frozen) ? sfCyan : sfWhite);

        sfRectangleShape_setOrigin(card_shape, V2(0.5f * size.x, 0));
        // @Hack: Translated it along the directional axes by the height to place in the right position once
        // it has been rotated 180 degrees so the card back texture looks the right way from the players point
        // of view
        sfRectangleShape_setPosition(card_shape, card_position - (size.y * tx->axes));
        sfRectangleShape_rotate(card_shape, Degrees(tx->angle));

        sfRenderWindow_drawRectangleShape(global_window, card_shape, 0);
    }

    // Render player cards
    sfRectangleShape_setOrigin(shadow, V2(0.5f * size.x, size.y));
    sfRectangleShape_setOrigin(card_shape, V2(0.5f * size.x, size.y));
    for (u32 it = 0; it < player->card_count; ++it) {
        // @Hack: If flags are present remove interaction from the hand
        if (!(player->state_flags & PlayerState_ViewingCards) && !(player->state_flags & PlayerState_RemovingHand)) {
            if ((it == hover_index) || (state->dragging && (it == state->dragging_index))) { continue; }
        }

        Card_Transform *tx = &transforms[it];
        Card *card = &player->cards[it];

        v2 card_position = player_hand_position + tx->offset;
        v2 shadow_offset = (8 * tx->axes) + (8 * Perp(tx->axes));

        // Draw drop shadow
        sfRectangleShape_setRotation(shadow, Degrees(tx->angle));
        sfRectangleShape_setPosition(shadow, card_position - shadow_offset);
        sfRenderWindow_drawRectangleShape(global_window, shadow, 0);

        // Draw card face
        sfTexture *texture = 0;
        if (card->effect_flags & CardStatus_Hidden) {
            texture = GetImage(&state->assets, GetCard(board->card_index, CardType_Back).image);
        }
        else {
            texture = GetImage(&state->assets, card->image);
        }

        sfRectangleShape_setFillColor(card_shape, (card->effect_flags & CardStatus_Frozen) ? sfCyan : sfWhite);
        sfRectangleShape_setTexture(card_shape, texture, true);
        sfRectangleShape_setPosition(card_shape, card_position);
        sfRectangleShape_setRotation(card_shape, Degrees(tx->angle));

        sfRenderWindow_drawRectangleShape(global_window, card_shape, 0);
    }

    if (player->has_card) {
        player->used_card_display_time -= input->delta_time;
        player->used_card_display_y_offset -= (100 * input->delta_time);

        f32 offset = player->used_card_display_y_offset;

        sfColor fade_out = { 255, 255, 255, 0 };
        fade_out.a = cast(u8) (255 * (player->used_card_display_time / 2));

        sfRectangleShape_setFillColor(card_shape, fade_out);
        sfRectangleShape_setPosition(card_shape, V2(50 + (0.5f * size.x), global_view_size.y - 150 + offset));
        sfRectangleShape_setTexture(card_shape, GetImage(&state->assets, player->used_card_image), true);
        sfRectangleShape_setRotation(card_shape, 0);

        sfRenderWindow_drawRectangleShape(global_window, card_shape, 0);

        if (player->used_card_display_time < 0) { player->has_card = false; }
    }

    if (enemy->has_card) {
        enemy->used_card_display_time -= input->delta_time;
        enemy->used_card_display_y_offset -= (100 * input->delta_time);

        f32 offset = enemy->used_card_display_y_offset;

        sfColor fade_out = { 255, 255, 255, 0 };
        fade_out.a = cast(u8) (255 * (enemy->used_card_display_time / 2));

        sfRectangleShape_setFillColor(card_shape, fade_out);
        sfRectangleShape_setPosition(card_shape,
                V2(global_view_size.x - 50 - (0.5f * size.x), (0.5f * size.y) + 150 - offset));
        sfRectangleShape_setTexture(card_shape, GetImage(&state->assets, enemy->used_card_image), true);
        sfRectangleShape_setRotation(card_shape, 0);

        sfRenderWindow_drawRectangleShape(global_window, card_shape, 0);

        if (enemy->used_card_display_time < 0) { enemy->has_card = false; }
    }

    sfRectangleShape_setFillColor(card_shape, sfWhite);

    if (turn->type == PlayerType_Computer) {
        // @Todo: AI goes here
        if (enemy->card_count > 0) {
            if (turn->card_use_time > 2) {
                turn->card_use_time = 0;

                u32 index = RandomChoice(enemy->card_count);
                if (enemy->cards[index].cost > enemy->mana && !enemy->has_card) { board->phase = TurnPhase_End; }
                else { UseCard(board, enemy, player, index); }
            }

            enemy->card_use_time += input->delta_time;
        }
        else if (!enemy->has_card) { board->phase = TurnPhase_End; }

        return;
    }

    if (HasActiveCard(enemy, CardType_DazzlingLight)) {
        if (player->card_count == 0) { board->phase = TurnPhase_End; }

        if (player->card_use_time > 2) {
            u32 index = RandomChoice(player->card_count);
            if (player->mana < player->cards[index].cost) {
                board->phase = TurnPhase_End;
            }

            UseCard(board, player, enemy, index);

            player->card_use_time = 0;
        }

        player->card_use_time += input->delta_time;
    }

    // @Todo: Make this more robust
    if (player->state_flags & PlayerState_ViewingCards) {
        bool draw_view = (player->state_flags & PlayerState_ViewingDraw);
        bool hand_view = (player->state_flags & PlayerState_ViewingHand);
        bool selecting = (player->state_flags & PlayerState_Selecting);

        Card *card_pool = 0;

        u32 card_count = 0;
        if (draw_view) {
            card_count = player->select_card_count;
            card_pool = enemy->deck + enemy->next_card_index;
        }
        else if (hand_view) {
            card_count = enemy->card_count;
            card_pool = enemy->cards;
        }
        else if (selecting) {
            card_count = player->card_count;
            card_pool = player->cards;
        }

        Assert(card_pool);

        if (card_count != 0) {
            sfRectangleShape *overlay = sfRectangleShape_create();
            sfColor colour = { 0, 0, 0, 85 };
            sfRectangleShape_setSize(overlay, global_view_size);
            sfRectangleShape_setFillColor(overlay, colour);

            sfRenderWindow_drawRectangleShape(global_window, overlay, 0);

            sfRectangleShape_destroy(overlay);
        }

        f32 padding = 20;
        v2 centre = 0.5f * global_view_size;
        f32 width = size.x + ((size.x + padding) * (card_count - 1));
        f32 begin_x = ((global_view_size.x - width) / 2) + (0.5f * size.x);
        f32 begin_y = (global_view_size.y / 5) + size.y;
        v2 begin = V2(begin_x, begin_y);
        v2 offset = V2(size.x + padding, 0);

        for (u32 it = 0; it < card_count; ++it) {
            Card *card = &card_pool[it];
            v2 card_position = begin + (it * offset) - V2(0, 0.5 * size.y);

            // For selecting cards!
            if (selecting) {
                v2 offset_mouse = input->mouse_position - card_position;
                if (Abs(offset_mouse.x) < (0.5f * size.x) && Abs(offset_mouse.y) < (0.5f * size.y)) {
                    if (JustPressed(input->mouse_buttons[0])) {
                        bool selected = (card->effect_flags & CardStatus_Selected);
                        if (selected && player->current_selected_count != 0) {
                            player->current_selected_count--;
                            card->effect_flags &= ~CardStatus_Selected;
                        }
                        else if (!selected && player->current_selected_count < player->select_card_count) {
                            player->current_selected_count++;
                            card->effect_flags |= CardStatus_Selected;
                        }
                    }
                }
            }

            v2 old_origin = sfRectangleShape_getOrigin(card_shape);
            sfRectangleShape_setRotation(card_shape, 0);
            sfRectangleShape_setOrigin(card_shape, 0.5f * size);
            sfRectangleShape_setPosition(card_shape, card_position);
            sfRectangleShape_setScale(card_shape, V2(1.05, 1.05));
            sfRectangleShape_setFillColor(card_shape, (card->effect_flags & CardStatus_Selected) ? sfYellow : sfWhite);
            sfRectangleShape_setTexture(card_shape, GetImage(&state->assets, state->glow_image), true);
            sfRenderWindow_drawRectangleShape(global_window, card_shape, 0);

            sfRectangleShape_setFillColor(card_shape, sfWhite);
            sfRectangleShape_setPosition(card_shape, begin + (it * offset));
            sfRectangleShape_setOrigin(card_shape, old_origin);
            sfRectangleShape_setScale(card_shape, V2(1, 1));
            sfRectangleShape_setTexture(card_shape, GetImage(&state->assets, card->image), true);

            sfRenderWindow_drawRectangleShape(global_window, card_shape, 0);
        }

        v2 confirm_pos = V2(global_view_size.x * 0.5f - state->confim_button_size.x * 0.5f,
                global_view_size.y * 0.5f);
        v2 offset_mouse = input->mouse_position - confirm_pos;

        sfRectangleShape *confirm = sfRectangleShape_create();
        sfRectangleShape_setPosition(confirm, confirm_pos);
        sfRectangleShape_setSize(confirm, state->confim_button_size);
        sfRectangleShape_setTexture(confirm, GetImage(&state->assets, state->confirm_image), true);

        sfRenderWindow_drawRectangleShape(global_window, confirm, 0);

        bool confirmed = false;
        if (offset_mouse.x >= 0 && offset_mouse.x < (0.5f * state->confim_button_size.x) &&
                offset_mouse.y >= 0 && offset_mouse.y < (0.5f * state->confim_button_size.y))
        {
            confirmed = true;
        }

        if (card_count == 0) {
            player->state_flags &= ~PlayerState_ViewingCards;
        }
        else if ((JustPressed(keyboard->confirm) || confirmed) && selecting) {
            for (u32 it = 0; it < card_count;) {
                // A selected card has been found
                if (card_pool[it].effect_flags & CardStatus_Selected) {
                    card_pool[it].effect_flags = 0;
                    enemy->cards[enemy->card_count++] = card_pool[it];
                    RemoveCard(player, it);
                    card_count--;
                }
                else {
                    it++;
                }
            }

            player->current_selected_count = 0;
            player->select_card_count = 0;
            player->state_flags &= ~PlayerState_ViewingCards;
        }
        else if (JustPressed(keyboard->menu) || JustPressed(keyboard->confirm) || confirmed) {
            player->state_flags &= ~PlayerState_ViewingCards;
        }



        sfRectangleShape_destroy(confirm);
        sfRectangleShape_destroy(card_shape);
        sfRectangleShape_destroy(shadow);
        return;
    }
    else if (player->state_flags & PlayerState_RemovingHand) {
        f32 padding = 20;
        v2 centre = 0.5f * global_view_size;
        f32 width = size.x + ((size.x + padding) * (enemy->card_count - 1));
        f32 begin_x = ((global_view_size.x - width) / 2) + (0.5f * size.x);
        f32 begin_y = (global_view_size.y / 5) + (0.5f * size.y);
        v2 begin = V2(begin_x, begin_y);
        v2 offset = V2(size.x + padding, 0);

        sfRectangleShape *overlay = sfRectangleShape_create();
        sfColor colour = { 0, 0, 0, 85 };
        sfRectangleShape_setSize(overlay, global_view_size);
        sfRectangleShape_setFillColor(overlay, colour);

        sfRenderWindow_drawRectangleShape(global_window, overlay, 0);

        sfRectangleShape_destroy(overlay);

        bool hit = false;
        v2 bbox_position = begin - V2(0.5f * size.x, size.y);
        v2 bbox_size = V2(width, size.y);

        v2 offset_mouse = input->mouse_position - bbox_position;
        if (offset_mouse.x < bbox_size.x && offset_mouse.x >= 0 &&
                offset_mouse.y < bbox_size.y && offset_mouse.y >= 0)
        {
            hit = true;
            for (u32 it = 0; it < enemy->card_count; ++it) { enemy->cards[it].effect_flags |= CardStatus_Selected; }

            if (JustPressed(input->mouse_buttons[0])) {
                for (u32 it = 0; it < enemy->card_count; ++it) {
                    enemy->graveyard[enemy->graveyard_next++] = enemy->cards[it];
                }

                enemy->card_count = 0;
                player->state_flags &= ~PlayerState_RemovingHand;
            }
        }
        else {
            for (u32 it = 0; it < enemy->card_count; ++it) { enemy->cards[it].effect_flags &= ~CardStatus_Selected; }
        }

        sfRectangleShape *bbox = sfRectangleShape_create();
        sfRectangleShape_setPosition(bbox, bbox_position);
        sfRectangleShape_setSize(bbox, bbox_size);
        sfRectangleShape_setOutlineThickness(bbox, 10);
        sfRectangleShape_setOutlineColor(bbox, hit ? sfGreen : sfBlue);
        sfRectangleShape_setFillColor(bbox, sfTransparent);

        sfRenderWindow_drawRectangleShape(global_window, bbox, 0);

        for (u32 it = 0; it < enemy->card_count; ++it) {
            Card *card = &enemy->cards[it];
            v2 card_position = begin + (it * offset) - V2(0, 0.5 * size.y);

            v2 old_origin = sfRectangleShape_getOrigin(card_shape);
            sfRectangleShape_setRotation(card_shape, 0);
            sfRectangleShape_setOrigin(card_shape, 0.5f * size);
            sfRectangleShape_setPosition(card_shape, card_position);
            sfRectangleShape_setScale(card_shape, V2(1.05, 1.05));
            sfRectangleShape_setFillColor(card_shape, (card->effect_flags & CardStatus_Selected) ? sfYellow : sfWhite);
            sfRectangleShape_setTexture(card_shape, GetImage(&state->assets, state->glow_image), true);
            sfRenderWindow_drawRectangleShape(global_window, card_shape, 0);

            sfRectangleShape_setFillColor(card_shape, sfWhite);
            sfRectangleShape_setPosition(card_shape, begin + (it * offset));
            sfRectangleShape_setOrigin(card_shape, old_origin);
            sfRectangleShape_setScale(card_shape, V2(1, 1));
            sfRectangleShape_setTexture(card_shape, GetImage(&state->assets, card->image), true);

            sfRenderWindow_drawRectangleShape(global_window, card_shape, 0);
        }

        width = size.x + ((size.x + padding) * (player->card_count - 1));
        begin_x = ((global_view_size.x - width) / 2) + (0.5f * size.x);
        begin_y = (global_view_size.y / 2) + (1.5f * size.y); // @Todo: Figure this out
        begin = V2(begin_x, begin_y);
        offset = V2(size.x + padding, 0);
        sfRectangleShape_setPosition(bbox, begin - V2(0.5f * size.x, size.y));
        sfRectangleShape_setSize(bbox, V2(width, size.y));

        hit = false;
        bbox_position = begin - V2(0.5f * size.x, size.y);
        bbox_size = V2(width, size.y);

        offset_mouse = input->mouse_position - bbox_position;
        if (offset_mouse.x < bbox_size.x && offset_mouse.x >= 0 &&
                offset_mouse.y < bbox_size.y && offset_mouse.y >= 0)
        {
            hit = true;
            for (u32 it = 0; it < player->card_count; ++it) { player->cards[it].effect_flags |= CardStatus_Selected; }

            if (JustPressed(input->mouse_buttons[0])) {
                for (u32 it = 0; it < player->card_count; ++it) {
                    player->graveyard[player->graveyard_next++] = player->cards[it];
                }

                player->card_count = 0;

                player->state_flags &= ~PlayerState_RemovingHand;
            }
        }
        else {
            for (u32 it = 0; it < player->card_count; ++it) { player->cards[it].effect_flags &= ~CardStatus_Selected; }
        }

        sfRectangleShape_setOutlineColor(bbox, hit ? sfGreen : sfBlue);
        sfRenderWindow_drawRectangleShape(global_window, bbox, 0);

        sfRectangleShape_destroy(bbox);

        for (u32 it = 0; it < player->card_count; ++it) {
            Card *card = &player->cards[it];
            v2 card_position = begin + (it * offset) - V2(0, 0.5 * size.y);

            v2 old_origin = sfRectangleShape_getOrigin(card_shape);
            sfRectangleShape_setRotation(card_shape, 0);
            sfRectangleShape_setOrigin(card_shape, 0.5f * size);
            sfRectangleShape_setPosition(card_shape, card_position);
            sfRectangleShape_setScale(card_shape, V2(1.05, 1.05));
            sfRectangleShape_setFillColor(card_shape, (card->effect_flags & CardStatus_Selected) ? sfYellow : sfWhite);
            sfRectangleShape_setTexture(card_shape, GetImage(&state->assets, state->glow_image), true);
            sfRenderWindow_drawRectangleShape(global_window, card_shape, 0);

            sfRectangleShape_setFillColor(card_shape, sfWhite);
            sfRectangleShape_setPosition(card_shape, begin + (it * offset));
            sfRectangleShape_setOrigin(card_shape, old_origin);
            sfRectangleShape_setScale(card_shape, V2(1, 1));
            sfRectangleShape_setTexture(card_shape, GetImage(&state->assets, card->image), true);

            sfRenderWindow_drawRectangleShape(global_window, card_shape, 0);
        }

        sfRectangleShape_destroy(card_shape);
        sfRectangleShape_destroy(shadow);
        return;
    }

    v2 mouse = input->mouse_position - state->end_turn_pos;
    if (mouse.x >= 0 && mouse.x < (0.5f * state->end_turn_size.x) && mouse.y >= 0 &&
            mouse.y < (0.5f * state->end_turn_size.y))
         {
             if (JustPressed(input->mouse_buttons[0])) {
                 board->phase = TurnPhase_End;
             }
         }

    // Show the card that is being hovered
    if (!state->dragging && hover_index != -1) {
        Card *card = &player->cards[hover_index];
        Card_Transform *tx = &transforms[hover_index];

        if (JustPressed(input->mouse_buttons[0])) {
            state->dragging = true;
            state->dragging_index = hover_index;
        }
        else {
            sfRectangleShape_setFillColor(card_shape, sfWhite);
            sfRectangleShape_setOrigin(card_shape, 0.5f * size);
            sfRectangleShape_setSize(card_shape, 2 * size);

            // @Todo: Make this more robust they don't feel like they are quite in the right place!
            v2 pos = player_hand_position + tx->offset + (0.5f * size.y * tx->axes) + V2(0, 100);
            sfRectangleShape_setRotation(shadow, 0);
            sfRectangleShape_setSize(shadow, 2 * size);
            sfRectangleShape_setPosition(shadow, pos - V2(50, -50));
            sfRenderWindow_drawRectangleShape(global_window, shadow, 0);

            sfRectangleShape_setOrigin(card_shape, V2(0.5f * size.x, 2 * size.y));
            sfRectangleShape_setPosition(card_shape, pos);
            sfRectangleShape_setRotation(card_shape, 0);

            sfTexture *texture = 0;
            if (card->effect_flags & CardStatus_Hidden) {
                texture = GetImage(&state->assets, GetCard(board->card_index, CardType_Back).image);
            }
            else {
                texture = GetImage(&state->assets, card->image);
            }

            sfRectangleShape_setTexture(card_shape, texture, true);
            sfRenderWindow_drawRectangleShape(global_window, card_shape, 0);
        }
    }

    // If the player is dragging around a card
    if (state->dragging) {
        Card *card = &player->cards[state->dragging_index];

        sfRectangleShape_setSize(shadow, 2 * size);
        sfRectangleShape_setOrigin(shadow, size);
        sfRectangleShape_setRotation(shadow, 0);
        sfRectangleShape_setPosition(shadow, input->mouse_position - V2(60, -60));
        sfRenderWindow_drawRectangleShape(global_window, shadow, 0);

        sfRectangleShape_setOrigin(card_shape, size);
        sfRectangleShape_setRotation(card_shape, 0);
        sfRectangleShape_setSize(card_shape, 2 * size);
        sfRectangleShape_setPosition(card_shape, input->mouse_position);

        sfTexture *texture = 0;
        if (card->effect_flags & CardStatus_Hidden) {
            texture = GetImage(&state->assets, GetCard(board->card_index, CardType_Back).image);
        }
        else {
            texture = GetImage(&state->assets, card->image);
        }

        sfRectangleShape_setTexture(card_shape, texture, true);
        sfRenderWindow_drawRectangleShape(global_window, card_shape, 0);

        if (!IsPressed(input->mouse_buttons[0])) {
            if (input->mouse_position.y < (0.5f * global_view_size.y)) {
                UseCard(board, player, enemy, state->dragging_index);
            }

            state->dragging = false;
            state->dragging_index = -1;
        }
    }

    if (JustPressed(keyboard->confirm)) {
        board->phase = TurnPhase_End;
    }

    sfRectangleShape_destroy(shadow);
    sfRectangleShape_destroy(card_shape);
}

// @Phase: End Phase
internal void ExecuteEndPhase(Game_State *state, Board_State *board, Game_Input *input) {
    u32 just_went = board->current_player_turn;

    Player *this_turn = &state->players[just_went];

    if (this_turn->card_count == 0) {
        this_turn->cleared_out = true;
        this_turn->health += 2;
        if (this_turn->max_mana < 10) { this_turn->max_mana++; }
    }

    this_turn->last_turn_health = this_turn->health;
    this_turn->last_turn_used_count = this_turn->turn_used_count;
    this_turn->turn_used_count = 0;

    board->damage_last_turn = board->damage_this_turn;
    board->sacrifice_damage_last_turn = board->sacrifice_damage_this_turn;

    board->damage_this_turn = 0;
    board->sacrifice_damage_this_turn = 0;

    this_turn->temp_mana_change = 0;

    for (u32 it = 0; it < this_turn->card_count; ++it) {
        Card *card = &this_turn->cards[it];

        if (card->hidden_turn_count != 0) { card->hidden_turn_count--; }
        if (card->frozen_turn_count != 0) { card->frozen_turn_count--; }

        if (card->hidden_turn_count == 0) { card->effect_flags &= ~CardStatus_Hidden; }
        if (card->frozen_turn_count == 0) { card->effect_flags &= ~CardStatus_Frozen; }
    }

    this_turn->new_card_flags = 0;

    if (HasActiveCard(this_turn, CardType_Recursion) && this_turn->mana < 2) {
        RemoveActiveCard(this_turn, CardType_Recursion);
    }

    // Advance to the next players turn
    board->current_player_turn = 1 - just_went;

    board->phase = TurnPhase_Draw;
}

////

internal void LudumUpdateRender(Game_State *state, Game_Input *input) {
    if (!state->initialised) {
        InitialiseCardIndex(&state->card_index, &state->assets);

        // @Todo: Maybe this should just be stored directly in the Board_State dunno if we'll need it
        // elsewhere
        state->board.card_index = &state->card_index;
        state->board.phase = TurnPhase_Draw;

        Music_Handle music_handle = LoadMusic(&state->assets, "data/music.wav");
        Assert(IsValid(music_handle));
        sfMusic *music = GetMusic(&state->assets, music_handle);

        sfMusic_setLoop(music, true);
        sfMusic_setVolume(music, 25);
        sfMusic_play(music);

        state->system_font = LoadFont(&state->assets, "data/ubuntu.ttf");

        state->inverted_start_image = LoadImage(&state->assets, "data/invert_start.png");
        state->start_image = LoadImage(&state->assets, "data/start.png");
        state->menu_image = LoadImage(&state->assets, "data/menu.png");
        state->confirm_image = LoadImage(&state->assets, "data/confirm.png");
        sfTexture *texture = GetImage(&state->assets, state->confirm_image);

        sfVector2u _conf = sfTexture_getSize(texture);
        state->confim_button_size = 0.5f * V2(_conf.x, _conf.y);

        state->mana_image = LoadImage(&state->assets, "data/mana_crystal2.png");
        state->end_turn_image = LoadImage(&state->assets, "data/end_turn.png");

        state->glow_image = LoadImage(&state->assets, "data/glow2.png");
        state->shadow_image = LoadImage(&state->assets, "data/shadow.png");
        state->board_image = LoadImage(&state->assets, "data/board.png");
        Assert(IsValid(state->board_image));

        Player *player = &state->players[0];
        player->type = PlayerType_Human;

        GetDeck(&state->board, player->deck, 0);
        player->deck[0] = GetCard(state->board.card_index, CardType_Charity);

        player->attack_modifier = 1;
        player->health = 20;
        player->max_mana = 0;

        Player *enemy = &state->players[1];
        enemy->attack_modifier = 1;
        enemy->health = 20;
        enemy->type = PlayerType_Computer;
        GetDeck(&state->board, enemy->deck, 1);

        state->in_menu = true;

        state->initialised = true;
    }

    if (state->in_menu) {
        sfRectangleShape *shape = sfRectangleShape_create();
        sfRectangleShape_setSize(shape, global_view_size);
        sfRectangleShape_setTexture(shape, GetImage(&state->assets, state->menu_image), true);

        sfRenderWindow_drawRectangleShape(global_window, shape, 0);

        v2 start_button_pos = V2(global_view_size.x - state->confim_button_size.x - 80, 230);
        sfRectangleShape_setPosition(shape, start_button_pos);
        sfRectangleShape_setSize(shape, state->confim_button_size);
        sfRectangleShape_setTexture(shape, GetImage(&state->assets, state->start_image), true);

        bool hit = false;
        v2 offset_mouse = input->mouse_position - start_button_pos;
        if (offset_mouse.x >= 0 && offset_mouse.x < (0.5f * state->confim_button_size.x) &&
                offset_mouse.y >= 0 && offset_mouse.y < (0.5f * state->confim_button_size.y))
        {
            sfRectangleShape_setTexture(shape, GetImage(&state->assets, state->inverted_start_image), true);
            hit = JustPressed(input->mouse_buttons[0]);
        }

        sfRenderWindow_drawRectangleShape(global_window, shape, 0);

        if (JustPressed(input->keyboard.confirm) || hit) {
            state->in_menu = false;
        }

        sfRectangleShape_destroy(shape);
    }
    else {
        // Draw the board
        // @Note: This happens regardless of phase or turn so might as well do it right away
        sfRectangleShape *board_shape = sfRectangleShape_create();
        sfRectangleShape_setPosition(board_shape, V2(0, 0));
        sfRectangleShape_setSize(board_shape, global_view_size);
        sfRectangleShape_setTexture(board_shape, GetImage(&state->assets, state->board_image), true);
        sfRenderWindow_drawRectangleShape(global_window, board_shape, 0);

        sfTexture *end_turn = GetImage(&state->assets, state->end_turn_image);

        sfVector2u _tex_size = sfTexture_getSize(end_turn);
        v2 tex_size = V2(_tex_size.x, _tex_size.y);

        sfRectangleShape_setPosition(board_shape, V2(global_view_size.x - (0.5F * tex_size.x) - 10,
                    (global_view_size.y * 0.5f) - (0.25f * tex_size.y)));
        sfRectangleShape_setSize(board_shape, 0.5f * tex_size);
        sfRectangleShape_setTexture(board_shape, end_turn, true);

        sfRenderWindow_drawRectangleShape(global_window, board_shape, 0);

        state->end_turn_pos = sfRectangleShape_getPosition(board_shape);
        state->end_turn_size = tex_size;

        sfRectangleShape_destroy(board_shape);

        Board_State *board = &state->board;
        switch (board->phase) {
            case TurnPhase_Draw: {
                ExecuteDrawPhase(state, board, input);
            }
            break;
            case TurnPhase_Play: {
                ExecutePlayPhase(state, board, input);
            }
            break;
            case TurnPhase_End: {
                ExecuteEndPhase(state, board, input);
            }
            break;
        }
    }
}
